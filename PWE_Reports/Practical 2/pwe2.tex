%        File: pwe2.tex
%     Created: Thu Apr 25 10:00  2019 S
% Last Change: Thu Apr 25 10:00  2019 S
%
\documentclass[a4paper, 12pt]{article}

\usepackage[]{amsmath, amssymb}
\usepackage{IEEEtrantools}
\usepackage[]{graphicx}
\usepackage{booktabs}
\usepackage{float}
\usepackage[toc, page]{appendix}
\usepackage[]{hyperref}

\title{Power Electronics: Designing and Building a Single Switch Flyback Converter}
\author{Ruan de Bruyn \and 216054484 \and Quintin Kruger \and 216008466}

\begin{document}

\pagenumbering{gobble}
\maketitle
\newpage
\pagenumbering{roman}
\tableofcontents
\listoffigures
\newpage
\pagenumbering{arabic}

\section{Introduction}

The purpose of this practical was to design and construct a Flyback converter.
The design specifications of this converter are given to us in the practical
guide, and this report shows the steps and reasoning we had while building the
converter. It's also worth noting that the practical guide recommended a
textbook on designing switching power supplies \cite{pressman}, which was used
extensively to understand and design a practical real-life flyback converter.

% endsection Introduction

\section{Design}

\subsection{Circuit Design}

\subsubsection{Design Specifications}

The student number we used to get the design specifications was 216054484. Following the practical guide, our design specifications are given as such:

\begin{table}[H]
  \centering
  \begin{tabular}{r c c}
    \toprule
    \textbf{Attribute} & \textbf{Symbol} & \textbf{Value} \\
    \midrule
    Power & $P_o$ & 20W \\
    Efficiency & $\eta$ & 80\% \\
    Maximum duty cycle & $D_{\text{max}}$ & 42.5\% \\
    Output voltage & $V_o$ & 18V \\
    Switching frequency & $f_{\text{sw}}$ & 25 kHz \\
    \bottomrule
  \end{tabular}
  \caption{Design Specifications}
  \label{tab:design_specs}
\end{table}

\subsubsection{Turns ratio}

We used the recommended textbook the practical \cite{pressman} during the
design of this converter. Since we have a switching frequency of $f_s = 25kHz$,
that leaves us with a period of

\begin{IEEEeqnarray}{rCl}
	T & = & \frac{1}{f_s} \nonumber \\
	& = & 40 \mu s
	\label{eq:T}
\end{IEEEeqnarray}

For stability and dynamic response reasons, we decided to have this flyback
converter operate in discontinuous mode. Thus, we will have an ``on'' time,
$T_{on}$, which will represent our duty cycle. There needs to be a ``reset''
time as well, to allow the inductor to completely dispose of the energy in its
magnetic field. \cite{pressman} recommends the following constraint:

\begin{equation}
	T_{on} + T_r = 0.8T
	\label{eq:time_constraint}
\end{equation}

Equation \eqref{eq:time_constraint} ensures that there is enough dead time
between cycles for the inductor to reset. Then, with our maximum duty cycle
being 42.5\%, we have

\begin{equation}
	T_{on} = D_{\text{max}} T = 17 \mu s
	\label{eq:ton}
\end{equation}

\noindent and from equation \eqref{eq:time_constraint}

\begin{IEEEeqnarray}{rCl}
	T_r & = & 0.8(40 \mu s) - 17 \mu s \nonumber \\
	& = & 15 \mu s
	\label{eq:tr}
\end{IEEEeqnarray}

leaving us with a dead time of about $8 \mu s$ per cycle to ensure
discontinuous mode operation. Next, we need to calculate the turns ratio for
the coupled inductor. With the assumed efficiency of $\eta = 80\%$ and a
specified output power of $P_o = 20 W$, this means we would have input power
$P_i = 25 W$. From a 12V DC power supply, we would then expect to draw an
average current of approximately 2A on the primary side. This is important,
because when calculating our turns ratio, the voltage drop across the switch on
the primary side needs to be taken into account. According to the IRF510 Power
MOSFET datasheet, it has an $R_{DS, on}$ of $0.54\Omega$. Granted, this was
measured with a primary current of 3.4A according to the datasheet, but this
should suffice as an approximation for us. Then we have a forward voltage drop
over the switch of approximately $V_{DS} = (2)(0.54) \approx 1V$. 

Then, on the secondary side, we require an output voltage of $V_o = 18V$.
However, our fast switching 1N4148 diode has a forward voltage drop of $V_f =
1V$, which means that the coupled inductor has to step up voltage to compensate
for this drop. Taking all of this into account, together with the fact that the
integral of the volt-seconds over the inductor should equal zero, we have

\begin{equation}
	(V_i - V_{DS})T_{on} = \frac{N_s}{N_p}(V_o + V_f)T_r
	\label{eq:turnsratio}
\end{equation}

Letting $\rho$ denote our turns ratio, and substituting for our known values,
it follows from \eqref{eq:turnsratio} that

\begin{IEEEeqnarray}{rCl}
  \rho & = & \frac{(V_i - V_{DS})T_{on}}{(V_o + V_f)T_r} \nonumber \\
	& = & \frac{(12 - 1)17 \times 10^{-6}}{(18 + 1)15 \times 10^{-6}} \nonumber \\
	& = & 0.656 \nonumber \\
	& \approx & 0.65
	\label{eq:rho}
\end{IEEEeqnarray}

\subsubsection{Primary and Secondary Side Inductances}

The inductance of the primary side of the coupled inductor comes next. The
proof of the equation for the primary inductance is covered in Pressman
\cite{pressman}, and is beyond the scope of this report. We will, however,
alter the equation as a function of efficiency (\cite{pressman} assumes a fixed
efficiency), which yields

\begin{equation}
	V_o = V_{i} T_{on} \sqrt{\frac{R_o}{\tfrac{2}{\eta}T L_p}} \Rightarrow L_p = \frac{(V_i T_{on})^2}{\tfrac{2}{\eta} T P_o}
	\label{eq:lp}
\end{equation}

Substituting our values, it leaves us with a primary inductance of

\begin{IEEEeqnarray}{rCl}
	L_p & = & \frac{(12 \times 17 \times 10^{-6})^2}{\tfrac{2}{0.8}(40 \times 10^{-6})(20)} \nonumber \\
	& = & 2.08 \times 10^{-5} \nonumber \\
	& = & 20.8 \mu H
	\label{eq:primary_inductance}
\end{IEEEeqnarray}

Getting the secondary inductance can be done with a simple ratio:

\begin{IEEEeqnarray}{rCl}
	L_s & = & \rho^{-2}L_p \nonumber \\
	& = & 0.65^{-2}(2.08 \times 10^{-5}) \nonumber \\
	& = & 4.925 \times 10^{-5} \nonumber \\
	& = & 49.3 \mu H
	\label{eq:secondary_inductance}
\end{IEEEeqnarray}

\subsubsection{Peak Currents}

In order to double check our peak currents, we can use the current through an
inductor equation, where

\begin{equation}
  i_L = \frac{1}{L} \int V_L dt
  \label{eq:inductor_current}
\end{equation}

Denoting peak primary current as $\hat{I_p}$, we get our primary peak current as
\begin{IEEEeqnarray}{rCl}
  \hat{I_p} & = & \frac{1}{L_p} \int_0^{T_{on}} V_i dt \nonumber \\
  & = & \frac{12}{20.8 \times 10 ^{-6}}(17 \times 10^{-6}) \nonumber \\
  & = & 9.8 A
  \label{eq:primary_current_peak}
\end{IEEEeqnarray}

In order to get the peak secondary current, we simply multiply it with $\rho$,
and get

\begin{IEEEeqnarray}{rCl}
  \hat{I_s} & = & \hat{I_p}\rho \nonumber \\
  & = & (9.8)(0.65) \nonumber \\
  & = & 6.38 A
\end{IEEEeqnarray}

Following a derivation in Chapter 2 of Pressman \cite{pressman}, we can get the
RMS current on both sides using the formula

\begin{equation}
  I_{rms} = \frac{\hat{I}}{\sqrt{3}}\sqrt{\frac{T'}{T}}
  \label{eq:rms_current_equation}
\end{equation}

Applying this formula with the results obtained for peak currents, we have

\begin{IEEEeqnarray}{rCl}
  I_{rms(primary)} = 3.69A \\
  I_{rms(secondary)} = 2.25A
\end{IEEEeqnarray}

% endsubsection Circuit Design

\subsection{Negative Feedback Control}

We decided to use a Raspberry Pi Model 3B+ as our PWM source for this circuit.
We made this choice because the Raspberry Pi has ample processing power for
this application; its 1.4GHz processorcan perform elementary operations with
sub-microsecond speed, and will ensure that our duty cycle --- which is on the
order of microseconds --- will stay constant while sensor data from the circuit
is being processed.

The MCP3008 IC was used as an analog-to-digital converter. This IC outputs a
digital signal to the Raspberry Pi via the Serial SPI interface with as a ratio
of the reference voltage provided to the chip with the formula

\begin{equation}
  V_{\text{digital}} = \frac{V_{\text{analog}}}{1024} V_{\text{ref}}
  \label{eq:mcp_formula}
\end{equation}

where $V_{\text{digital}}$ is quantized to be an integer. However, the MCP3008
can only take a maximum $V_{\text{ref}}$ of 5.5V, according to the datasheet,
meaning we need to step down our load voltage to be less than that if we are to
implement effective control (and not damage the chip). This is done by the
voltage divider resistors that are parallel to the load. <+ADD PROPER LABELS
FOR RESISTORS ONCE SCHEMATICS ARE PUT IN+>. Since the voltage over the smaller
resistor is measured by our A/D converter, we essentially step down our load
voltage with as given by \eqref{eq:voltage_divider}.

\begin{equation}
  V_{\text{analog}} = \frac{10}{100 + 10}V_o = \frac{1}{11} V_o
  \label{eq:voltage_divider}
\end{equation}

Now, we supply the A/D converter with a reference voltage of $V_{\text{ref}} =
5.2V$, from the 5V DC output of the Raspberry Pi (the documentation says that
the output is 5V, but we measured it to be 5.2V). This means that our load can
have an output voltage of $11 \times 5.2 = 57.2V$ before the IC will start
giving erroneous output or become damaged. Since our output voltage is 18V, we
feel that this adds a sufficient buffer to protect the Raspberry Pi and the IC.
A quick calculation also reveals that, with a reference voltage of 5.2 volts,
the A/D converter has a voltage resolution of approximately 5mV, which is more
than sufficient for controlling the output voltage of the converter. The actual
code for negative feedback control is given in Appendix
\ref{sec:feedback_code}.

The PWM that this code ultimately controls is supplied from the Raspberry Pi to
the circuit via an ICL7667 inverting MOSFET driver, which steps up the 3.3V PWM
from the Raspberry Pi to a 12V signal. This can comfortably drive our MOSFET
past its threshold gate voltage. The MOSFET driver has protection circuitry
internally built in to the package, which not only serves to protect the driver
from any inductive effects from our MOSFET, but also protects the Raspberry Pi.
When we initially built the circuit, we noticed large spikes at the output of
of the driver, and followed advice from the manufacturer's datasheet and put a
small capacitor at the output of the driver to even out the spikes somewhat.
<+ADD REFERENCE TO PWM MEASUREMENT TO PROVE THIS+>


% endsubsection Negative Feedback Control

% endsection Design
\section{Construction}

% endsection Construction

\section{Results and Discussion}

% endsection Results and Discussion

\begin{thebibliography}{0}
	\bibitem{pressman} A. Pressman, K. Billings, T. Morey, \textit{Switching Power Supply Design, Third Edition}, Chapter 4 --- Flyback Converter Topologies
\end{thebibliography}

\newpage
\begin{appendices}
	\section{Negative Feedback Code}
	\label{sec:feedback_code}
	Below is the code that was implemented for negative feedback control in
	the Raspberry Pi. The code was implemented in the C programming
	language, and compiled using the GCC compiler with the relevant
	compiling flags to the libraries used. Note that the algorithm
	implements a PI type controller. The reasoning for this specific choice
	came from a lecture on PWM control in Power Electronics, where Dr.
	Pentz stated that an integrator constant acts as a low-pass filter,
	avoiding excessive readings from noise, whereas a derivative constant
	acts as a high-pass filter, increasing the noise instead.
	
	Lastly, it's worth noting that this algorithm was able to execute
	successfully without any significant impact on the PWM frequency, due
	to the Raspberry Pi's processing speed, and the use of threads for
	concurrent processing. There is some code that takes user input in the
	main function. This was simply for demonstration purposes, so we could
	easily run the PWM program through the terminal, and safely quit all
	the threads with a single command.\\\\\noindent
	\texttt{\#include <wiringPi.h>} \\\noindent
	\texttt{\#include <stdio.h>} \\\noindent
	\texttt{\#include <stdlib.h>} \\\noindent
	\texttt{\#include <stdint.h>} \\\noindent
	\texttt{\#include <time.h>} \\\noindent
	\texttt{\#include <pthread.h>} \\\noindent
	\texttt{\#include <math.h>} \\\noindent
	\texttt{\#include <stdbool.h>} \\\noindent
	\texttt{\#include <mcp3004.h>} \\\noindent
	\texttt{ \\\noindent}
	\texttt{\#define BASE 100} \\\noindent
	\texttt{\#define SPI\_CHAN 0} \\\noindent
	\texttt{ \\\noindent}
	\texttt{double period = 40;} \\\noindent
	\texttt{const double D\_MAX = 0.425;} \\\noindent
	\texttt{const double D\_MIN = 0.025;} \\\noindent
	\texttt{double duty\_cycle = 0.425;} \\\noindent
	\texttt{int voltage = 0;} \\\noindent
	\texttt{double normalized\_voltage = 0.0;} \\\noindent
	\texttt{double error = 0.0;} \\\noindent
	\texttt{int ref\_voltage = 18;} \\\noindent
	\texttt{const int vref = 5;} \\\noindent
	\texttt{const double r\_factor = 11 * 5.2 / 1024;} \\\noindent
	\texttt{double p = 0.0125;} \\\noindent
	\texttt{double p\_i = 0.003;} \\\noindent
	\texttt{ \\\noindent}
	\texttt{bool running = true;} \\\noindent
	\texttt{ \\\noindent}
	\texttt{void *run\_pwm()} \\\noindent
	\texttt{\{ \\\noindent}
	\texttt{ \\\noindent}
	\texttt{\hspace*{1em}double fixed\_cycle = 0;} \\\noindent
	\texttt{\hspace*{1em}int t\_on = 0;} \\\noindent
	\texttt{\hspace*{1em}int t\_off = 0;} \\\noindent
	\texttt{\hspace*{1em}int x;} \\\noindent
	\texttt{\hspace*{1em}while(running)\{ \\\noindent}
	\texttt{\hspace*{2em}fixed\_cycle = duty\_cycle;} \\\noindent
	\texttt{\hspace*{2em}t\_on = round(period * fixed\_cycle);} \\\noindent
	\texttt{\hspace*{2em}t\_off = round(period * (1 - fixed\_cycle));} \\\noindent
	\texttt{\hspace*{2em}digitalWrite(1, LOW);} \\\noindent
	\texttt{\hspace*{2em}delayMicroseconds(t\_on);} \\\noindent
	\texttt{\hspace*{2em}digitalWrite(1, HIGH);} \\\noindent
	\texttt{\hspace*{2em}delayMicroseconds(t\_off);} \\\noindent
      \texttt{\hspace*{1em}\}} \\\noindent
	\texttt{\hspace*{1em}	} \\\noindent
	\texttt{\hspace*{1em}// Clean up the output pins for safety} \\\noindent
	\texttt{\hspace*{1em}digitalWrite(1, LOW);} \\\noindent
	\texttt{\hspace*{1em}pinMode(1, 0);} \\\noindent
	\texttt{\hspace*{1em}}\\\noindent
        \texttt{ \\\noindent}
        \texttt{void *controller()} \\\noindent
        \texttt{\{ \\\noindent}
	\texttt{\hspace*{1em}const int size\_max = 10;} \\\noindent
	\texttt{\hspace*{1em}double i\_values[10] = \{\};} \\\noindent
	\texttt{\hspace*{1em}size = 0;} \\\noindent
	\texttt{\hspace*{1em}double sum = 0;} \\\noindent
	\texttt{\hspace*{1em}while(running)} \\\noindent
	\texttt{\hspace*{2em}\{ \\\noindent}
	\texttt{\hspace*{2em}// run until cancel} \\\noindent
	\texttt{\hspace*{2em}// get measurements} \\\noindent
	\texttt{\hspace*{2em}voltage = analogRead(BASE);} \\\noindent
	\texttt{\hspace*{2em}normalized\_voltage = voltage * r\_factor;} \\\noindent
	\texttt{\hspace*{2em}error = ref\_voltage - normalized\_voltage;} \\\noindent
	\texttt{\hspace*{2em}\\\noindent}
	\texttt{\hspace*{2em}// Add error value to integrator} \\\noindent
	\texttt{\hspace*{2em}if(size < size\_max) \{ \\\noindent}
	\texttt{\hspace*{3em}size++;} \\\noindent
	\texttt{\hspace*{3em}i\_values[size - 1] = error;} \\\noindent
	\texttt{\hspace*{2em}\}} \\\noindent
	\texttt{\hspace*{2em}else \{ \\\noindent}
	\texttt{\hspace*{3em}// shift old values} \\\noindent
	\texttt{\hspace*{3em}int i;} \\\noindent
	\texttt{\hspace*{3em}for(i = 0; i < size\_max - 1; i++)} \\\noindent
	\texttt{\hspace*{3em}i\_values[i] = i\_values[i + 1];} \\\noindent
	\texttt{\hspace*{3em}i\_values[size\_max - 1] = error;} \\\noindent
	\texttt{\hspace*{2em}\}} \\\noindent
	\texttt{ \\\noindent}
	\texttt{\hspace*{2em}// sum values for integrator} \\\noindent
	\texttt{\hspace*{2em}int i;} \\\noindent
	\texttt{\hspace*{2em}sum = 0;} \\\noindent
	\texttt{\hspace*{2em}for(i = 0; i < size; i++)} \\\noindent
	\texttt{\hspace*{2em}sum += i\_values[i];} \\\noindent
	\texttt{\hspace*{2em}\\\noindent}
	\texttt{\hspace*{2em}// adjust duty cycle accordingly} \\\noindent
	\texttt{\hspace*{2em}duty\_cycle += p * error + p\_i * sum;} \\\noindent
	\texttt{ \\\noindent}
	\texttt{\hspace*{2em}if(duty\_cycle > D\_MAX)} \\\noindent
	\texttt{\hspace*{3em}duty\_cycle = D\_MAX;} \\\noindent
	\texttt{ \\\noindent}
	\texttt{\hspace*{2em}if(duty\_cycle < D\_MIN)} \\\noindent
	\texttt{\hspace*{3em}duty\_cycle = D\_MIN;} \\\noindent
	\texttt{ \\\noindent}
	\texttt{\hspace*{2em}delayMicroseconds(500);} \\\noindent
	\texttt{\hspace*{1em}\}}\\\noindent
        \texttt{\}} \\\noindent
        \texttt{ \\\noindent}

	\texttt{main(void) \{ \\\noindent}
	\texttt{\hspace*{1em}// setup physical} \\\noindent
	\texttt{\hspace*{1em}wiringPiSetup();} \\\noindent
	\texttt{\hspace*{1em}mcp3004Setup(BASE, SPI\_CHAN);} \\\noindent
	\texttt{\hspace*{1em}pinMode(1, OUTPUT); } \\\noindent
	\texttt{\hspace*{1em}\\\noindent}
	\texttt{\hspace*{1em}pthread\_t thread\_1;} \\\noindent
	\texttt{\hspace*{1em}pthread\_t thread\_2;} \\\noindent
	\texttt{\hspace*{1em}pthread\_create(\&thread\_1, NULL, run\_pwm, NULL);} \\\noindent
	\texttt{\hspace*{1em}pthread\_create(\&thread\_2, NULL, controller, NULL);} \\\noindent
	\texttt{\hspace*{1em}\\\noindent}
	\texttt{\hspace*{1em}char* line = NULL;} \\\noindent
	\texttt{\hspace*{1em}size\_t len = 0;} \\\noindent
	\texttt{\hspace*{1em}ssize\_t read = 0;} \\\noindent
	\texttt{\hspace*{1em}\\\noindent}
	\texttt{\hspace*{1em}while(running)} \\\noindent
	\texttt{\hspace*{2em}\{ \\\noindent}
	\texttt{\hspace*{2em}while (read != -1) \{ \\\noindent}
	\texttt{\hspace*{3em}puts("Enter q to quit");} \\\noindent
	\texttt{\hspace*{3em}read = getline(\&line, \&len, stdin);} \\\noindent
	\texttt{\hspace*{3em}puts("");} \\\noindent
	\texttt{\hspace*{3em}if (!strcmp(line, "q")) \{ \\\noindent}
	\texttt{\hspace*{4em}running = false;} \\\noindent
	\texttt{\hspace*{4em}break;} \\\noindent
	\texttt{\hspace*{3em}\}} \\\noindent
	\texttt{\hspace*{2em}\}} \\\noindent
	\texttt{\hspace*{1em}\}} \\\noindent
	\texttt{\hspace*{1em}\\\noindent}
	\texttt{\hspace*{1em}free(line);} \\\noindent
	\texttt{\hspace*{1em}pthread\_join(thread\_1, NULL);} \\\noindent
	\texttt{\hspace*{1em}pthread\_join(thread\_2, NULL);} \\\noindent
	\texttt{\hspace*{1em}\\\noindent}
	\texttt{\hspace*{1em}return 0;} \\\noindent
        \texttt{\}} \\\noindent

\end{appendices}

\end{document}
